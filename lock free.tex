\documentclass{article}
\usepackage[english,russian]{babel}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{natbib}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{hyperref}

\title{Неблокирующая синхронизация}
\author{Скомпоновал доклад Евгений}
\date{Май 2019}

\begin{document}

\maketitle

\section{Введение}

Неблокирующая синхронизация (lock free) — подход в параллельном программировании на симметрично-многопроцессорных системах, в котором принят отказ от традиционных примитивов блокировки, таких, как семафоры, мьютексы и события. Разделение доступа между потоками идёт за счёт атомарных операций и специальных, разработанных под конкретную задачу, механизмов блокировки.\\

Преимущество неблокирующих алгоритмов — в лучшей масштабируемости по количеству процессоров. К тому же, если ОС прервёт один из потоков фоновой задачей, остальные, как минимум, выполнят свою работу, не простаивая. Как максимум — возьмут невыполненную работу на себя.\\

Одно из важных последствий программирования без блокировок: даже если один поток будет находиться в состоянии ожидания, он не помешает прогрессу остальных потоков в их собственных lock-free операциях. Это определяет ценность программирования без блокировок при написании обработчиков прерываний и систем реального времени, когда определенная задача должна быть завершена за ограниченный отрезок времени, независимо от состояния остальной программы.\\

Механизмы программирования без блокировок:
\begin{itemize}
 \item Атомарные операции;
 \item Барьеры памяти;
 \item Volatile;
 \item И другие.
\end{itemize}

\section{Методы lock free}
\subsection{Атомарные операции}

Атомарные операции — это такие операции, которые производят неделимые манипуляции памятью: ни один поток не может наблюдать такую операцию на промежуточной стадии выполнения. В современных процессорах многие операции уже атомарны. Например, обычно являются атомарными выровненные операции чтения/записи простых типов.\\

Атомарные операции делятся на простые — чтение и запись — и операции атомарного изменения (read-modify-write, RMW). Атомарную операцию можно определить как неделимую операцию: она либо уже произошла, либо ещё нет; мы не можем увидеть никаких промежуточных стадий её выполнения, никаких частичных эффектов. В этом смысле даже простые операции чтения/записи, в принципе, могут быть не атомарными; например, чтение невыровненных данных является неатомарным: в архитектуре x86 такое чтение приведет к внутреннему исключению, заставляющему процессор читать данные частями, в других архитектурах (Sparc, Intel Itanium) – к фатальной ошибке (segmentation fault), которую, в принципе, можно перехватить и обработать, но об атомарности речи здесь быть уже не может. В современных процессорах гарантируется атомарность чтения/записи только выровненных простых (integral) типов – целых чисел и указателей. Современный компилятор гарантирует правильное выравнивание переменных базовых типов, хотя написать пример невыровненного обращения, например, к целому, не составляет труда. Если же вы хотите атомарно работать со структурой (по размеру влезающей в 4 – 8 байт), то следует самим позаботиться о правильном выравнивании с помощью директив (атрибутов) компилятора (каждый компилятор поддерживает свой уникальный способ указания выравнивания данных/типов). 

Возможно, наиболее обсуждаемая RMW-операция — compare-and-swap (CAS). разработчики процессорных архитектур внедрили RMW-операции, способные атомарно выполнить чтение выровненной ячейки памяти и запись в неё: compare-and-swap (CAS)\\

Сценарий использования CAS обычно включает в себя копирование разделяемой переменной в локальную, совершение над ней какой-то работы и попытку опубликовать изменения, используя CAS.\\
Сигнатура метода CAS:
\begin{lstlisting}
public static object CompareExchange (ref object location1, 
                                      object value, 
                                      object comparand);
\end{lstlisting}
\textit{location1 - целевой объект \\ 
value - объект, заменяющий целевой \\ 
comparand - значение, с которым сравнивается \\
Возращаемое значение - значение из location1}

Примитив CAS всем хорош, но при его применении возможна серьезная проблема, получившая название ABA-проблемы. [\ref{aba-problem}]

\subsection{Барьеры памяти и модель памяти .NET}

Любой современный процессор может переставлять инструкции чтения и записи памяти в целях оптимизации. Поясню это на примере.

\begin{lstlisting}
int a = _a;
_b = 10;
\end{lstlisting}

В данном коде вначале читается переменная \_a, затем записывается \_b. Но при исполнении данной программы процессор может переставить местами инструкции чтения и записи, то есть вначале будет записана переменная \_b, и только потом прочтена \_a. Для однопоточной программы такая перестановка не имеет значения, но для многопоточной программы это может превратиться в проблему. Сейчас мы рассмотрели перестановку загрузка – запись. Аналогичные перестановки возможны и для других сочетаний инструкций.\\

Совокупность правил перестановок таких инструкций называется моделью памяти. Платформа .NET имеет собственную модель памяти, которая абстрагирует нас от моделей памяти конкретного процессора. 
Так выглядит модель памяти .NET \\

\begin{tabular}{ | c | c | }
\hline
Тип перестановки & Перестановка разрешена \\
\hline
Загрузка-загрузка & Да \\
Загрузка-запись & Да \\
Запись-загрузка & Да \\
Запись-запись & Нет \\
\hline
\end{tabular}

Для решения проблемы перестановки инструкций существует универсальный метод — добавление барьера памяти(memory barrier, memory fence). \\

Существует несколько видов барьеров памяти: \textbf{полный}, \textbf{release fence} и \textbf{acquire fence}. Полный барьер гарантирует, что все чтения и записи расположенные до/после барьера будут выполнены так же до/после барьера, то есть никакая инструкция обращения к памяти не может перепрыгнуть барьер. \\ \\
Теперь разберемся с двумя другими видами барьеров:\\
Acquire fence гарантирует что инструкции, стоящие после барьера, не будут перемещены в позицию до барьера.\\
Release fence гарантирует, что инструкции, стоящие до барьера, не будут перемещены в позицию после барьера.\\

Еще пару слов о терминологии. Термин volatile write означает выполнение записи в память в сочетании с созданием release fence. Термин volatile read означает чтение памяти в сочетании с созданием acquire fence.

\section{Проблемы при распараллеливании}
\subsection{ABA-проблема}
\label{aba-problem}
В многозадачных вычислениях проблема ABA возникает при синхронизации, когда ячейка памяти читается дважды, оба раза прочитано одинаковое значение, и признак «значение одинаковое» трактуется как «ничего не менялось».
Вот пример последовательности событий, ведущих к проблеме ABA:
\begin{itemize}
    \item Процесс P1 читает значение A из разделяемой памяти
    \item P1 вытесняется, позволяя выполняться P2
    \item P2 меняет значение A на B и обратно на A перед вытеснением
    \item P1 возобновляет работу, видит, что значение не изменилось
    \item и продолжает...
\end{itemize}

Обычно с проблемой ABA сталкиваются при реализации lock-free структур и алгоритмов. Если из списка удалить элемент, уничтожить его, а затем создать новый элемент и добавить обратно в список, есть вероятность, что новый элемент будет размещён на месте старого (в памяти). Указатель на новый элемент совпадёт с указателем на старый, что и приведёт к проблеме: равенство признаков не есть равенство данных целиком.\\

Средство борьбы с ABA-проблемой – отложенное физическое удаление элемента в момент, когда есть полная гарантия, что никто (ни один из конкурирующих потоков) не имеет ни локальных, ни глобальных ссылок на удаляемый элемент.
Таким образом, удаление элемента из lock-free структуры является двухфазным:
\begin{itemize}
    \item Первая фаза – исключение элемента из lock-free контейнера;
    \item Вторая фаза (отложенная) – физическое удаление элемента, когда нет никаких ссылок на него.
\end{itemize}

\subsection{False sharing}

В современных процессорах длина линии кэша L (cache line) составляет 64 – 128 байт и имеет тенденцию к увеличению в новых моделях. Обмен данными между основной памятью и кэшем осуществляется блоками по L байт (обычно L – степень двойки). При изменении хотя бы одного байта в линии кэша вся линия считается инвалидной и требует синхронизации с основной памятью. Этим управляет протокол поддержки когерентности кэшей в мультипроцессорной/мультиядерной архитектуре.
Если разные разделяемые данные попадают в одну линию кэша (то есть расположены в смежных адресах), то изменение одних данных приводит, с точки зрения процессора, к инвалидации других, находящихся в той же линии кэша. Эта ситуация называется false sharing (ложное связывание).
Борьба с false sharing довольно проста (но расточительна): каждая shared-переменная должна занимать линию кэша целиком; для этого обычно используют заполнение (padding):

\begin{lstlisting}
struct Foo {
   int volatile nShared1;
   char   _padding1[64];	 // padding for cache line=64 byte
   int volatile nShared2;
   char   _padding2[64];	 // padding for cache line=64 byte
};
\end{lstlisting}

\subsection{Оптимизации вносимые компилятором}

Основные проблемы, с которыми сталкивается программист при использовании неблокирующей синхронизацией, это оптимизации компилятора и перестановка инструкций процессором. \\

\begin{lstlisting}
class ReorderTest
{
   private int _a;

   public void Foo()
   {
       var task = new Task(Bar);
       task.Start();
       Thread.Sleep(1000);
       _a = 0;
       task.Wait();
   }

   public void Bar()
   {
       _a = 1;
       while (_a == 1)
       {
       }
   }
}
\end{lstlisting}

Запустив этот пример можно убедится, что программа зависает. Причина кроется в том, что компилятор кэширует переменную \_a в регистре процессора.\\

Для решения подобных проблем C\# предоставляет ключевое слово volatile. Применение этого ключевого слова к переменной запрещает компилятору как-либо оптимизировать обращения к ней.

\subsection{Перестановка инструкций}

Рассмотрим теперь случай, когда источником проблем является перестановка инструкций процессором.
Пусть имеется следующий код: \\
\begin{lstlisting}
class ReorderTest2
{
   private int _a;
   private int _b;

   public void Foo()
   {
       _a = 1;
       _b = 1;
   }

   public void Bar()
   {
       if (_b == 1)
       {
           Console.WriteLine(_a);
       }
   }
}
\end{lstlisting}

Процедуры Foo и Bar запускаются одновременно из разных потоков. \\

Является ли данный код корректным, то есть, можем ли мы с уверенностью сказать, что программа никогда не выведет нуль? Если бы речь шла об однопоточных программах, то для проверки этого кода было бы достаточно единожды запустить его на выполнение. Но, так как мы имеем дело с многопоточностью, этого недостаточно. 


\begin{thebibliography}{9}
\bibitem{ref1} \href{https://habr.com/ru/post/195948/}{Lock-free структуры данных. Основы: Атомарность и атомарные примитивы / Хабр}
\bibitem{ref2} \href{https://habr.com/ru/company/wunderfund/blog/322094/}{Введение в lock-free программирование}
\bibitem{ref3} \href{https://afana.me/archive/2015/07/10/memory-barriers-in-dot-net.aspx/}{Memory Barriers in .NET · Nadeem Afana's Blog}
\bibitem{ref4} \href{https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D0%B0_ABA}{Проблема ABA — Википедия}
\bibitem{ref5} \href{https://habr.com/ru/post/130318/}{Барьеры памяти и неблокирующая синхронизация в .NET / Хабр}
\bibitem{ref62} \href{https://docs.microsoft.com/ru-ru/dotnet/csharp/language-reference/keywords/volatile}{Справочник по C#. volatile | Microsoft Docs}
\end{thebibliography}
\end{document}